package main

import "fmt"

//Где нам могут помочь интерфейсы?
//Интерфейсы позволяют определить какую-то обобщенную реализацию без привязки к конкретному типу.
//Например, рассмотрим следующую ситуацию:

type Car2 struct{}
type Aircraft2 struct{}

func (c Car2) move2() {
	fmt.Println("Автомобиль едет")
}
func (a Aircraft2) move2() {
	fmt.Println("Самолет летит")
}

func driveCar(c Car2) {
	c.move2()
}
func driveAircraft(a Aircraft2) {
	a.move2()
}

func main() {

	var tesla2 Car2 = Car2{}
	var boing2 Aircraft2 = Aircraft2{}
	driveCar(tesla2)
	driveAircraft(boing2)
}

//Допустим, в данном случае определены две структуры Car2 и Aircraft2, которые представляют автомобиль и самолет.
//Для каждой из структур определен метод перемещения move2(), который условно перемещает транспортное средство.
//И также определены две функции driveCar() и driveAircraft(), которые принимают соответственно структуры Car2 и Aircraft2
//и предназначены для вождения этих транспортных средств.

//И отчетливо видно, что обе функции driveCar и driveAircraft фактически идентичны, они выполняют один и те же действия,
//только для разных типов.
//И было бы неплохо, если можно было бы определить одну обобщенную функцию для разных типов.
//Особенно учитывая, что у нас может быть и больше транспортных средств - велосипед, корабль и т.д.
//И для вождения каждого транспортного средства придется определять свой метод, что не очень удобно.
//И как раз в этом случае можно воспользоваться интерфейсами в example3.go (см. файл example3.go)
